package main

import (
	"fmt"
	"log"

	"github.com/ayo-awe/advent-of-code-2024/aoc"
)

type pos [2]int

func (p pos) x() int { return p[0] }
func (p pos) y() int { return p[1] }
func (p pos) isOutOfBounds(dimensions [2]int) bool {
	return p.x() < 0 || p.x() >= dimensions[0] || p.y() < 0 || p.y() >= dimensions[1]
}

func parseInput(input []string) [][]rune {
	var cells [][]rune
	for _, line := range input {
		cells = append(cells, []rune(line))
	}
	return cells
}

func main() {
	input, err := aoc.ReadInputLineByLine("input.txt")
	if err != nil {
		log.Fatal(err)
	}

	grid := parseInput(input)
	fmt.Println("solution to part one: ", PartOne(grid))
	fmt.Println("solution to part two: ", PartTwo(grid))
}

func PartOne(grid [][]rune) int {
	antinodeFn := func(a, b pos, dimensions [2]int) []pos {
		var antinodes []pos
		dx, dy := a.x()-b.x(), a.y()-b.y()

		// upper antinode
		antinodeA := pos{a.x() + dx, a.y() + dy}
		if !antinodeA.isOutOfBounds(dimensions) {
			antinodes = append(antinodes, antinodeA)
		}

		// lower anitode
		antinodeB := pos{b.x() - dx, b.y() - dy}
		if !antinodeB.isOutOfBounds(dimensions) {
			antinodes = append(antinodes, antinodeB)
		}

		return antinodes
	}

	return countAntinodes(grid, antinodeFn)
}

func PartTwo(grid [][]rune) int {
	antinodeFn := func(a, b pos, dimensions [2]int) []pos {
		var antinodes []pos
		dx, dy := a.x()-b.x(), a.y()-b.y()

		antinodeA := pos{a.x(), a.y()}
		for !antinodeA.isOutOfBounds(dimensions) {
			antinodes = append(antinodes, antinodeA)
			antinodeA[0] += dx
			antinodeA[1] += dy
		}

		antinodeB := pos{b.x(), b.y()}
		for !antinodeB.isOutOfBounds(dimensions) {
			antinodes = append(antinodes, antinodeB)
			antinodeB[0] -= dx
			antinodeB[1] -= dy
		}

		return antinodes
	}

	return countAntinodes(grid, antinodeFn)
}

// given the position of two antenna's, it returns all the antinodes generated by them
type antinodeFunc func(a, b pos, dimensions [2]int) []pos

// returns the count of all unique antinodes on the grid and generated by the antinodeFn
func countAntinodes(grid [][]rune, antinodeFn antinodeFunc) int {
	antennaMap := make(map[rune][]pos)
	seenAntinodes := make(map[pos]struct{})
	dimensions := [2]int{len(grid[0]), len(grid)}

	for y, row := range grid {
		for x, antenna := range row {
			if antenna == '.' {
				continue
			}

			for _, node := range antennaMap[antenna] {
				if node.y() == y {
					continue
				}

				antinodes := antinodeFn(node, pos{x, y}, dimensions)
				for _, antinode := range antinodes {
					seenAntinodes[antinode] = struct{}{}
				}
			}

			antennaMap[antenna] = append(antennaMap[antenna], pos{x, y})
		}
	}

	return len(seenAntinodes)
}
